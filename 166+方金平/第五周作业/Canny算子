'''
Canny算子的简要步骤:
1,去噪声：应用高斯滤波来平滑图像，目的去噪声
2,梯度：找寻图像的梯度
3,非极大值抑制：过滤掉非边缘像素，将模糊的边界变得清晰。该过程保留了每个像素点上梯度强度的极大值，过滤掉其他值
4,应用双阈值的方法来决定可能的（潜在的）边界
5,利用滞后技术来跟踪边界。若某一像素位置和强边界相连的弱边界认为是边界，其他的弱边界则被删除
'''


import cv2
import numpy as np
import matplotlib.pyplot as plt

#读取图像
img = cv2.imread('D:/baduzl/badou/2/dama/lenna.png')
lenna_img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)

#灰度化处理

GrayImg = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

#调用高斯滤波降噪

gassion = cv2.GaussianBlur(GrayImg,(3,3),0)

#canny算子
#edges = Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])
#其中，参数：mage 表示输入图像；edges 表示输出的边缘图，其大小和类型与输入图像相同；threshold1 表示第一个滞后性阈值；
# threshold2 表示第二个滞后性阈值；apertureSize 表示应用Sobel算子的孔径大小，其默认值为3；L2gradient 表示一个计算图像梯度幅值的标识，默认值为false。

Canny = cv2.Canny(gassion,50,200)

#显示中文标签
plt.rcParams['font.sans-serif'] = ['SimHei']

#显示图像
titles = [u'原始图像' , u'Canny算子']
images = [lenna_img,Canny]
for i in range(2):
     plt.subplot(1,2,i+1), plt.imshow(images[i],'gray')
     plt.title(titles[i])
     plt.xticks(([])),plt.yticks([])
plt.show()
